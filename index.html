<!DOCTYPE html>
<html>
<head>
  <title>0x isometric engine</title>
  <style>
    html {
      color: white;
      font-size: 10px;
      font-family: arial, sans;
    }
    body {
      text-align: center;
      background-color: #2E3436;
    }
    canvas {
      border: 1px solid #4C5153;
      cursor: crosshair;
    }
    a {
      color: white;
    }
    section.panel {
      text-align: left;
      border: 1px solid #4C5153;
      background-color: #2E3436;
      padding: 1rem;
      position: absolute;
      top: 0;
      right: 0;
      opacity: 0.5;
      -webkit-transition: opacity 0.2s;
      -moz-transition:    opacity 0.2s;
      -o-transition:      opacity 0.2s;
      transition:         opacity 0.2s;
    }
    section.panel:hover {
      opacity: 1;
    }
    section.panel h2 {
      font-size: 1.8rem;
      padding: 0;
      padding-bottom: 0.5rem;
      margin: 0;
      border-bottom: 1px solid #4C5153;
    }
    section.panel pre {
      margin: 1rem 0;
    }
    #viewer {
      left: 2rem;
      top: 2rem;
      font-size: 1.5rem;
    }
  </style>
  <script>
    var g = [[0,20,'grass']];
    var S = [[0,20,'grass'], [20,110,'big-stone']];
    var r = [[0,10,'river-surface']];
    var R = [[0,10,'river-ripple']];
    var s = [[0,20,'small-stone']];
    var p = [[0,115,'gate-left']];
    var d = [[0,20],[96,115,'gate-top']];
    var P = [[0,115,'gate-right']];
    var b = [[0,10,'river-surface'], [55,70,'bridge-left']];
    var B = [[0,10,'river-surface'], [55,70,'bridge-right']];
    var c = [[0,20]];
    var e = [[0,20,'grass'], [20,35,'bridge-support-small-left']];
    var E = [[0,20,'grass'], [20,35,'bridge-support-small-right']];
    var f = [[0,20,'grass'], [20,80,'bridge-support-big-left']];
    var F = [[0,20,'grass'], [20,80,'bridge-support-big-right']];
    var level = {
      name: 'testing map',
      tile_side: 40,
      base_level: 40,
      world: [
        [S, g, s, p, g, g, g, g, g, g, g, g],
        [g, g, g, d, g, g, g, g, g, g, g, g],
        [g, g, g, [[0,15]], P, g, g, g, g, g, g, g],
        [g, g, [[0,12]], s, s, g, r, g, g, g, g, g],
        [g, g, [[0,11]], g, g, g, r, r, g, g, g, g],
        [g, g, [[0,10]], g, g, r, R, R, g, g, g, g],
        [g, g, r, g, g, r, r, r, R, c, g, g],
        [g, g, r, R, r, r, r, r, b, c, g, g],
        [g, g, r, r, r, r, r, r, b, B, g, g],
        [g, g, r, r, r, r, r, b, B, r, g, g],
        [g, g, g, r, r, R, S, b, B, r, r, g],
        [g, g, r, r, r, g, f, B, r, r, r, g],
        [g, g, R, r, r, g, e, F, r, R, r, r],
        [g, r, r, r, g, c, [[0,20,'grass'], [20,35,'bridge-support-small-right']], g, r, r, r, R],
//        [g, r, r, r, g, g, c, g, g, r, r, r],
//        [r, r, r, g, g, g, c, g, g, r, r, r],
      ]
    }
  </script>
  <script>
    'use strict';

    function memoize(f) {
      var cache = {};
      return function() {
        var key = JSON.stringify([].slice.call(arguments, 0));
        if (!(key in cache))
          cache[key] = f.apply(this, arguments);

        return cache[key];
      };
    }

    Math.sin = memoize(Math.sin);
    Math.cos = memoize(Math.cos);

    function occluse(reference, target) {
      return false;
      if (!reference) {
        return false;
      }
      var i = target.i,
          j = target.j,
          ri = reference.i,
          rj = reference.j;

      if (!heightMap[rj] || !heightMap[rj][ri]) {
        return false;
      }

/*      if (!(rj % 2)) {
        if (!(j > rj && i === ri))
          return false;
//               j > rj && j % 2 === 0 && i === ri + 1;
      } else {
        return j > rj && i === ri ||
               j > rj && j % 2 === 1 && i === ri - 1;
      }
*/
      var current = heightMap[j][i].map(function (height) {
        var getPoint = pointMaker(i, j, height[0], height[1]);
        return [getPoint(0).y, getPoint(3).y];
      });

      var selected = heightMap[rj][ri].map(function (height) {
        var getPoint = pointMaker(ri, rj, height[0], height[1]);
        return [getPoint(0).y, getPoint(3).y];
      });

      var overlaps = false;
      var l = Math.min(current.length, selected.length);
      for (var i = 0; i < l && !overlaps; i++) {
        var rA = current[i],
            rB = selected[i];
        overlaps = !(rA[1] >= rB[0] || rB[1] >= rA[0]);
      }
      if (!overlaps) {
        return false;
      }

      return true;
    }

    var arc = 2*Math.PI/6;
    function pointMaker(i, j, h0, h1) {
      var x = i ? i * tileInfo.step.x : 0,
          y = j ? j * tileInfo.step.y : 0,
          even = !(j % 2),
          side = tileInfo.side;
      if (!even) {
        x += tileInfo.step.x / 2;
      }
      return memoize(function getPoint(i) {
        switch (i) {
          case 0:
            return { x: x, y: y - h0 };
          case 1:
            return {
              x: side * Math.cos(arc*(3.5)) + x,
              y: side * Math.sin(arc*(3.5)) + y - h0
            };
          case 2:
          case 3:
          case 4:
            return {
              x: side * Math.cos(arc*(i+1.5)) + x,
              y: side * Math.sin(arc*(i+1.5)) + y - h1
            };
          case 5:
            return {
              x: side * Math.cos(arc*(-0.5)) + x,
              y: side * Math.sin(arc*(-0.5)) + y - h0
            };
          case 6:
            return { x: x, y: y - h1 };
        }
      });
    }

    var character = null;
    function makeCharacter() {
      if (!character) {
        return;
      }

      var getPoint = pointMaker(character.i, character.j, 0, 80);
      ctx.save();
      ctx.globalAlpha = 1.0;

      // top face
      ctx.beginPath();
      ctx.moveTo(getPoint(3).x, getPoint(3).y);
      ctx.lineTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.closePath();
      ctx.fillStyle = 'red';
      ctx.fill();

      // rigth face
      ctx.beginPath();
      ctx.moveTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(5).x, getPoint(5).y);
      ctx.lineTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#FF3737';
      ctx.fill();
      ctx.stroke();

      // left face
      ctx.beginPath();
      ctx.moveTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(1).x, getPoint(1).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#AA0000';
      ctx.fill();

      ctx.restore();
    }

    function makeCube(i, j, h0, h1) {
      var getPoint = pointMaker(i, j, h0, h1);
      var refTile = { i: i, j: j };

      ctx.save();
      ctx.globalAlpha = 0.5;//occluse(cursorTile, refTile) ? 0.3 : 1.0;
      ctx.strokeStyle = 'black';

      if (cursorTile && sameTile(cursorTile, refTile)) {
        ctx.strokeStyle = 'green';
      }
      else if (selectedTile && sameTile(selectedTile, refTile)) {
        ctx.strokeStyle = 'red';
      }

      // top face
      ctx.beginPath();
      ctx.moveTo(getPoint(3).x, getPoint(3).y);
      ctx.lineTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.closePath();
      ctx.fillStyle = '#33393A';
      ctx.fill();
      ctx.stroke();

      // rigth face
      ctx.beginPath();
      ctx.moveTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(5).x, getPoint(5).y);
      ctx.lineTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#485152';
      ctx.fill();
      ctx.stroke();

      // left face
      ctx.beginPath();
      ctx.moveTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(1).x, getPoint(1).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#2A2F30';
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    function makeTile(i, j, h0, tileName) {
      var origin = pointMaker(i, j, h0, h0)(0);
      var img = tiles[tileName];
      if ('bridge-support-small-right'===tileName){
        var origin = pointMaker(i, j, 20, h0)(0);
        ctx.drawImage(img, origin.x - (img.naturalWidth/2),
                           origin.y - img.naturalHeight)
        return;
      }
      ctx.drawImage(img, origin.x - (img.naturalWidth / 2),
                         origin.y - img.naturalHeight)
    }

    var showLogicalWorld = false;
    function makeColumn(i, j) {
      var heights = heightMap[j][i];
      for (var h = 0, l = heights.length; h < l; h++) {
        var height = heights[h];
        if (height[2]) {
          makeTile(i, j, height[0], height[2]);
        }

        if (showLogicalWorld){
          makeCube(i, j, height[0], height[1]);
        }
      }
    }
    document.addEventListener('keypress', function (evt) {
      if (evt.charCode === 'l'.charCodeAt(0)) {
        showLogicalWorld = !showLogicalWorld;
        cls();
        render();
      }
    });

    function makeRow(j) {
      for (var i=0; i<heightMap[j].length; i++) {
        makeColumn(i, j);
      }
    }

    function makeGrid() {
      for (var j=0; j<heightMap.length; j++) {
        makeRow(j);
      }
    }

    var currentPanel, currentOffset;
    function makeFloatPanels() {
      var body = document.getElementsByTagName('body')[0];
      var panels = document.getElementsByClassName('panel');
      body.addEventListener('dragover', function(evt) {
        evt.preventDefault();
        return false;
      });
      body.addEventListener('drop', function(evt) {
        var data = evt.dataTransfer.getData('text/plain').split(',');
        var panel = document.getElementById(data[2]);
        panel.style.left = (event.clientX + parseInt(data[0], 10)) + 'px';
        panel.style.top = (event.clientY + parseInt(data[1], 10)) + 'px';
        evt.preventDefault();
        return false;
      });
      [].forEach.call(panels, function enablePanel(panel, index) {
        panel.setAttribute('draggable', true);
        if (!panel.id) {
          panel.id = 'panel-' + index;
        }
        panel.addEventListener('dragstart', function (evt) {
          var style = window.getComputedStyle(evt.target, null);
          evt.dataTransfer.setData('text/plain',
            (parseInt(style.left, 10) - evt.clientX) + ',' +
            (parseInt(style.top, 10) - evt.clientY) + ',' + panel.id);
        });
      });
    }

    function showCenter() {
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(0, 10);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(10, 0);
      ctx.stroke();
      ctx.restore();
    }

    function cls() {
      ctx.clearRect(-1000, -1000, 3000, 3000);
    }

    var canvas, ctx, tileInfo = {};
    function setup(width) {
      var side = (width/2.0)/Math.cos(Math.PI/6.0);
      tileInfo.side = side;
      tileInfo.step = {
        x: width,
        y: side / 2
      };
      canvas = document.getElementById('background');
      ctx = canvas.getContext('2d');
      makeFloatPanels();
    }

    function getOrigin(gridPoint) {
      var even = !(gridPoint.j % 2);
      return {
        x: (gridPoint.i + 0.5) * tileInfo.step.x,
        y: (gridPoint.j + (even ? 1 : 0)) * tileInfo.step.y
      };
    }

    function mod(v) {
      return Math.sqrt(v.x*v.x + v.y*v.y);
    }

    var ANGLE_30 = Math.PI/6;
    var ANGLE_150 = 5*ANGLE_30; 
    function getFixing(pos, o, gridPoint) {
      var even = !(gridPoint.j % 2);
      var v = {
        x: pos.x - o.x,
        y: pos.y - o.y
      };
      var angle = Math.acos(v.x/mod(v));
      var fixing = { i: 0, j: 0 };
      if (even) {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 2;
        } else if (angle < ANGLE_150) {
          fixing.j = 1;
        } else {
          fixing.j = 2;
        }
      } else {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 1;
        } else if (angle < ANGLE_150) {
          fixing.j = 2;
        } else {
          fixing.j = 1;
        }
      }
      return fixing;
    }

    function getCanvasPoint(evt) {
      var rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top - cameraOffset.y
      };
    }

    function getTile(evt) {
      var c = getCanvasPoint(evt);
      var gridPoint = {
        i: Math.floor(c.x/tileInfo.step.x),
        j: Math.floor(c.y/tileInfo.step.y)
      }
      var o = getOrigin(gridPoint);
      var fixing = getFixing(c, o, gridPoint);
      return {
        i: gridPoint.i + fixing.i,
        j: gridPoint.j + fixing.j
      }
    }

    var currentTool = { id: '', data: {} };
    function getEnabledTool() {
      var tools = document.getElementsByName('tool');
      for (var i = 0, l = tools.length; i < l; i++) {
        var option = tools[i];
        if (option.checked) {
          if (option.value !== currentTool.id) {
            currentTool.id = option.value;
            currentTool.data = {};
          }
          return currentTool;
        }
      }
    }

    function sameTile(t1, t2) {
      return t1 === t2 || (t1.i === t2.i && t1.j === t2.j);
    }

    function onMouseDown(evt) {
      getEnabledTool();
      switch (currentTool.id) {
        case 'select':
          var tile = getTile(evt);
          if (selectedTile && sameTile(selectedTile, tile)) {
            selectedTile = null;
          } else {
            selectedTile = tile;
          }
          break;
        case 'extrude':
          currentTool.data.enabled = true;
          currentTool.data.start = getCanvasPoint(evt);
          currentTool.data.tile = selectedTile;
          break;
      }
    }

    function onMouseUp(evt) {
      getEnabledTool();
      switch (currentTool.id) {
        case 'extrude':
          currentTool.data.enabled = false;
          break;
      }
    }

    var cursorTile = null;
    var selectedTile = null;
    function onMove(evt) {
      getEnabledTool();
      switch (currentTool.id) {
        case 'select':
          cursorTile = getTile(evt);
          break;
        case 'extrude':
          if (selectedTile && currentTool.data.enabled) {
            var pos = getCanvasPoint(evt);
            var tile = currentTool.data.tile;
            var getPoint = pointMaker(tile.i, tile.j, 0, 0);
            var s = Math.max(0, getPoint(0).y - currentTool.data.start.y);
            var h = s + Math.max(0, currentTool.data.start.y - pos.y);
            heightMap[tile.j][tile.i][0] = [s, h];
          }
          break;
      }
      cls();
      render();
    }

    var heightMap = level.world;
    /*function setupGrid(width, deep) {
      for (var y = 0; y < deep; y++) {
        heightMap.push([]);
        for (var x = 0; x < width; x++) {
          heightMap[y].push([]);
          heightMap[y][x].push([0, level.world]);
        }
      }
    }*/

    function ortoGrid(width, height) {
      return;
      ctx.save();
      ctx.strokeStyle = 'green';
      for (var x=0; x<width+1; x++) {
        ctx.beginPath();
        ctx.moveTo(x*tileInfo.step.x, -1000);
        ctx.lineTo(x*tileInfo.step.x, +1000);
        ctx.stroke();
      }

      for (var y=0; y<height*2; y++) {
        ctx.beginPath();
        ctx.moveTo(-1000, y*tileInfo.side/2);
        ctx.lineTo(+1000, y*tileInfo.side/2);
        ctx.stroke();
      }
      ctx.restore();
    }
  </script>
</head>
<body>
  <canvas id="background" width="1000" height="650" onmousemove="onMove(event)" onmouseup="onMouseUp(event)" onmousedown="onMouseDown(event)"></canvas>
  <p>
    <img id="tile-grass" src="img/grass.png" alt="Grass"/>
    <img id="tile-big-stone" src="img/big-stone.png" alt="Big stone"/>
    <img id="tile-small-stone" src="img/small-stone.png" alt="Small stone"/>
    <img id="tile-river-surface" src="img/river-surface.png" alt="River surface"/>
    <img id="tile-river-ripple" src="img/river-ripple.png" alt="River surface with ripples"/>
    <img id="tile-bridge-left" src="img/bridge-left.png" alt="Left part of the bridge"/>
    <img id="tile-bridge-right" src="img/bridge-right.png" alt="Right part of the bridge"/>
    <img id="tile-gate-left" src="img/gate-left.png" alt="Gate, left part"/>
    <img id="tile-gate-right" src="img/gate-right.png" alt="Gate, right part"/>
    <img id="tile-gate-top" src="img/gate-top.png" alt="Gate, top part"/>
    <img id="tile-bridge-support-big-left" src="img/bridge-support-big-left.png" alt="Bridge big support left"/>
    <img id="tile-bridge-support-big-right" src="img/bridge-support-big-right.png" alt="Bridge big support right"/>
    <img id="tile-bridge-support-small-left" src="img/bridge-support-small-left.png" alt="Bridge small support left"/>
    <img id="tile-bridge-support-small-right" src="img/bridge-support-small-right.png" alt="Bridge small support right"/>
  </p>
  <script>
    var tiles, cameraOffset, render;
    setTimeout(function () {
      'use strict';

      tiles = {
        'grass': document.getElementById('tile-grass'),
        'big-stone': document.getElementById('tile-big-stone'),
        'small-stone': document.getElementById('tile-small-stone'),
        'river-surface': document.getElementById('tile-river-surface'),
        'river-ripple': document.getElementById('tile-river-ripple'),
        'bridge-left': document.getElementById('tile-bridge-left'),
        'bridge-right': document.getElementById('tile-bridge-right'),
        'gate-left': document.getElementById('tile-gate-left'),
        'gate-right': document.getElementById('tile-gate-right'),
        'gate-top': document.getElementById('tile-gate-top'),
        'bridge-support-big-left': document.getElementById('tile-bridge-support-big-left'),
        'bridge-support-big-right': document.getElementById('tile-bridge-support-big-right'),
        'bridge-support-small-left': document.getElementById('tile-bridge-support-small-left'),
        'bridge-support-small-right': document.getElementById('tile-bridge-support-small-right')
      };

      setup(70);
  //    setupGrid(15, 15);
      cameraOffset = { x: 0, y: canvas.height/2};
      render = function () {
        ctx.setTransform(1, 0, 0, 1, cameraOffset.x, cameraOffset.y);
        makeGrid();
  //      showCenter();
        ortoGrid(10, 10);
      };
      render();
    }, 1000);
  </script>
</body>
</html>

