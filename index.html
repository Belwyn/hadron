<!DOCTYPE html>
<html>
<head>
  <title>0x isometric engine</title>
  <style>
    html {
      color: white;
      font-size: 10px;
      font-family: arial, sans;
    }
    body {
      text-align: center;
      background-color: #2E3436;
    }
    canvas {
      border: 1px solid #4C5153;
      cursor: crosshair;
    }
    a {
      color: white;
    }
    section.panel {
      text-align: left;
      border: 1px solid #4C5153;
      background-color: #2E3436;
      padding: 1rem;
      position: absolute;
      opacity: 0.5;
      -webkit-transition: opacity 0.2s;
      -moz-transition:    opacity 0.2s;
      -o-transition:      opacity 0.2s;
      transition:         opacity 0.2s;
    }
    section.panel:hover {
      opacity: 1;
    }
    section.panel h2 {
      font-size: 1.8rem;
      padding: 0;
      padding-bottom: 0.5rem;
      margin: 0;
      border-bottom: 1px solid #4C5153;
      cursor: move;
    }
    section.panel pre {
      margin: 1rem 0;
    }
    #viewer {
      left: 2rem;
      top: 2rem;
      font-size: 1.5rem;
    }
  </style>
  <script>
    'use strict';

    function memoize(f) {
      var cache = {};
      return function() {
        var key = JSON.stringify([].slice.call(arguments, 0));
        if (!(key in cache))
          cache[key] = f.apply(this, arguments);

        return cache[key];
      };
    }

    Math.sin = memoize(Math.sin);
    Math.cos = memoize(Math.cos);

    function occluseSelection(i, j) {
      var w = heightMap[0].length,
          d = heightMap.length
      if (selectedTile.i < 0 || selectedTile.j < 0 ||
          selectedTile.i >= w || selectedTile.j >= d) {
        return false;
      }

      var h = pointMaker(i, j, heightMap[j][i])(6).y;
      var b = pointMaker(selectedTile.i, selectedTile.j,
                         heightMap[selectedTile.j][selectedTile.i])(0).y;
      if (h>=b) {
        return false;
      }

      if (selectedTile.j % 2) {
        return j > selectedTile.j && i === selectedTile.i ||
               j > selectedTile.j && j % 2 === 0 && i === selectedTile.i + 1;
      } else {
        return j > selectedTile.j && i === selectedTile.i ||
               j > selectedTile.j && j % 2 === 1 && i === selectedTile.i - 1;
      }
    }

    var arc = 2*Math.PI/6;
    function pointMaker(i, j, h) {
      h = h || 0;
      var x = i ? i * tileInfo.step.x : 0,
          y = j ? j * tileInfo.step.y : 0,
          even = !(j % 2),
          side = tileInfo.side;
      if (!even) {
        x += tileInfo.step.x / 2;
      }
      return memoize(function getPoint(i) {
        switch (i) {
          case 0:
            return { x: x, y: y };
          case 1:
            return {
              x: side * Math.cos(arc*(3.5)) + x,
              y: side * Math.sin(arc*(3.5)) + y
            };
          case 2:
          case 3:
          case 4:
            return {
              x: side * Math.cos(arc*(i+1.5)) + x,
              y: side * Math.sin(arc*(i+1.5)) + y - h
            };
          case 5:
            return {
              x: side * Math.cos(arc*(-0.5)) + x,
              y: side * Math.sin(arc*(-0.5)) + y
            };
          case 6:
            return { x: x, y: y-h };
        }
      });
    }

    function makeCube(i, j, h) {
      var getPoint = pointMaker(i, j, h);

      ctx.save();
      ctx.strokeStyle = (i === selectedTile.i && j === selectedTile.j) ?
                        'red' : 'black';

      // top face
      ctx.beginPath();
      ctx.moveTo(getPoint(3).x, getPoint(3).y);
      ctx.lineTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.closePath();
      ctx.fillStyle = '#33393A';
      !occluseSelection(i, j) && ctx.fill();
      occluseSelection(i, j) && (ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)');
      ctx.stroke();

      // rigth face
      ctx.beginPath();
      ctx.moveTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(5).x, getPoint(5).y);
      ctx.lineTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#485152';
      !occluseSelection(i, j) && ctx.fill();
      occluseSelection(i, j) && (ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)');
      ctx.stroke();

      // left face
      ctx.beginPath();
      ctx.moveTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(1).x, getPoint(1).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#2A2F30';
      !occluseSelection(i, j) && ctx.fill();
      occluseSelection(i, j) && (ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)');
      ctx.stroke();
    }

    function makeRow(j) {
      for (var i=0; i<heightMap[j].length; i++) {
        var h = heightMap[j][i];
        makeCube(i, j, h);
      }
    }

    function makeGrid() {
      for (var j=0; j<heightMap.length; j++) {
        makeRow(j);
      }
    }

    var currentPanel, currentOffset;
    function makeFloatPanels() {
      var body = document.getElementsByTagName('body')[0];
      var panels = document.getElementsByClassName('panel');
      body.addEventListener('mousemove', function(evt) {
        if (currentPanel) {
          currentPanel.style.top = evt.clientY - currentOffset.y + 'px';
          currentPanel.style.left = evt.clientX - currentOffset.x + 'px';
        }
      });
      [].forEach.call(panels, function enablePanel(panel) {
        var title = panel.getElementsByTagName('h2')[0];
        var moving = false;
        title.addEventListener('mousedown', function(evt) {
          currentPanel = panel;
          currentOffset = {
            x: evt.clientX - panel.offsetLeft,
            y: evt.clientY - panel.offsetTop,
          };
        });
        title.addEventListener('mouseup', function() {
          currentPanel = null;
        });
      });
    }

    function showCenter() {
      ctx.save();
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(0, 10);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(10, 0);
      ctx.stroke();
      ctx.restore();
    }

    function cls() {
      ctx.clearRect(-1000, -1000, 3000, 3000);
    }

    var canvas, ctx, tileInfo = {};
    function setup(side) {
      tileInfo.side = side;
      tileInfo.step = {
        x: 2 * pointMaker(0, 0, side)(5).x,
        y: side / 2
      };
      canvas = document.getElementById('background');
      ctx = canvas.getContext('2d');
      makeFloatPanels();
    }

    function getOrigin(gridPoint) {
      var even = !(gridPoint.j % 2);
      return {
        x: (gridPoint.i + 0.5) * tileInfo.step.x,
        y: (gridPoint.j + (even ? 1 : 0)) * tileInfo.step.y
      };
    }

    function mod(v) {
      return Math.sqrt(v.x*v.x + v.y*v.y);
    }

    var ANGLE_30 = Math.PI/6;
    var ANGLE_150 = 5*ANGLE_30; 
    function getFixing(pos, o, gridPoint) {
      var even = !(gridPoint.j % 2);
      var v = {
        x: pos.x - o.x,
        y: pos.y - o.y
      };
      var angle = Math.acos(v.x/mod(v));
      var fixing = { i: 0, j: 0 };
      if (even) {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 2;
        } else if (angle < ANGLE_150) {
          fixing.j = 1;
        } else {
          fixing.j = 2;
        }
      } else {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 1;
        } else if (angle < ANGLE_150) {
          fixing.j = 2;
        } else {
          fixing.j = 1;
        }
      }
      return fixing;
    }

    function getCanvasPoint(evt) {
      var rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top - canvas.height/2
      };
    }

    function getTile(canvas, evt) {
      var c = getCanvasPoint(evt);
      var gridPoint = {
        i: Math.floor(c.x/tileInfo.step.x),
        j: Math.floor(c.y/tileInfo.step.y)
      }
      var o = getOrigin(gridPoint);
      var fixing = getFixing(c, o, gridPoint);
      return {
        i: gridPoint.i + fixing.i,
        j: gridPoint.j + fixing.j
      }
    }

    var selectedTile = { x: 0, y: 0 };
    function onMove(evt) {
      var tile = getTile(canvas, evt);
      if (!extrude.enabled) {
        selectedTile = tile;
      } else {
        var c = getCanvasPoint(evt);
        var h = Math.max(0, extrude.y - c.y);
        heightMap[selectedTile.j][selectedTile.i] = h;
      }
      cls();
      render();
    }

    var extrude = { enabled: false, x: 0, y: 0 };
    function onMouseDown(evt) {
      extrude.enabled = true;
      var rect = canvas.getBoundingClientRect();
      var c = {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top - canvas.height/2
      };
      extrude.x = c.x;
      extrude.y = c.y;
    }

    function onMouseUp(evt) {
      extrude.enabled = false;
    }

    var heightMap = [];
    function setupGrid(width, deep) {
      for (var y = 0; y < deep; y++) {
        heightMap.push([]);
        for (var x = 0; x < width; x++) {
          heightMap[y].push(0);
        }
      }
    }

    function ortoGrid(width, height) {
      ctx.save();
      ctx.strokeStyle = 'green';
      for (var x=0; x<width+1; x++) {
        ctx.beginPath();
        ctx.moveTo(x*tileInfo.step.x, -1000);
        ctx.lineTo(x*tileInfo.step.x, +1000);
        ctx.stroke();
      }

      for (var y=0; y<height*2; y++) {
        ctx.beginPath();
        ctx.moveTo(-1000, y*tileInfo.side/2);
        ctx.lineTo(+1000, y*tileInfo.side/2);
        ctx.stroke();
      }
      ctx.restore();
    }
  </script>
</head>
<body>
  <canvas id="background" width="1000" height="650" onmousemove="onMove(event)" onmouseup="onMouseUp(event)" onmousedown="onMouseDown(event)"></canvas>
  <script>
    'use strict';
    setup(50);
    setupGrid(10, 10);
    function render() {
      ctx.setTransform(1, 0, 0, 1, 0, canvas.height/2);
      makeGrid();
//      showCenter();
//      ortoGrid(10, 10);
    }
    render();
  </script>
</body>
</html>

