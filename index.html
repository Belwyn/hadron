<!DOCTYPE html>
<html>
<head>
  <title>0x isometric engine</title>
  <style>
    html {
      color: white;
      font-size: 10px;
      font-family: arial, sans;
    }
    body {
      text-align: center;
      background-color: #2E3436;
    }
    canvas {
      border: 1px solid #4C5153;
      cursor: crosshair;
    }
    a {
      color: white;
    }
    section.panel {
      text-align: left;
      border: 1px solid #4C5153;
      background-color: #2E3436;
      padding: 1rem;
      position: absolute;
      top: 0;
      right: 0;
      opacity: 0.5;
      -webkit-transition: opacity 0.2s;
      -moz-transition:    opacity 0.2s;
      -o-transition:      opacity 0.2s;
      transition:         opacity 0.2s;
    }
    section.panel:hover {
      opacity: 1;
    }
    section.panel h2 {
      font-size: 1.8rem;
      padding: 0;
      padding-bottom: 0.5rem;
      margin: 0;
      border-bottom: 1px solid #4C5153;
    }
    section.panel pre {
      margin: 1rem 0;
    }
    #viewer {
      left: 2rem;
      top: 2rem;
      font-size: 1.5rem;
    }
  </style>
  <script>
    var g = [[0,20,'small-grass']];
    var G = [[0,20,'big-grass']];
    var S = [[0,20,'big-grass'], [20,20,'big-stone']];
    var r = [[0,10,'river-surface']];
    var R = [[0,10,'river-ripple']];
    var s = [[0,20,'small-stone']];
    var p = [[0,115,'gate-left']];
    var d = [[0,20],[96,115,'gate-top']];
    var P = [[0,115,'gate-right']];
    var b = [[0,10,'river-surface'], [55,70,'bridge-left']];
    var B = [[0,10,'river-surface'], [55,70,'bridge-right']];
    var c = [[0,20]];
    var e = [[0,20,'big-grass'], [20,35,'bridge-support-small-left']];
    var E = [[0,20,'big-grass'], [20,35,'bridge-support-small-right']];
    var f = [[0,20,'big-grass'], [20,70,'bridge-support-big-left']];
    var F = [[0,20,'big-grass'], [20,70,'bridge-support-big-right']];
    var h = [[0,20,'big-grass'], [20,35,'bridge2-support-small-left']];
    var H = [[0,20,'big-grass'], [20,35,'bridge2-support-small-right']];
    var i = [[0,20,'big-grass'], [20,70,'bridge2-support-big-left']];
    var I = [[0,20,'big-grass'], [20,70,'bridge2-support-big-right']];
    var w = [[0,15]];
    var x = [[0,12]];
    var y = [[0,11]];
    var z = [[0,10]];
    var level = {
      name: 'testing map',
      tile_side: 40,
      base_level: 40,
      world: [
        [S, G, s, p, w, G, G, G, G, G, G, G],
        [ G, G, g, d, G, G, g, G, G, G, G, G],
        [g, g, g, w, P, G, g, g, g, G, s, G],
        [ g, g, x, s, s, g, r, g, g, G, G, g],
        [g, g, y, g, G, g, r, r, g, g, G, g],
        [ g, g, z, g, g, r, R, R, g, h, g, g],
        [g, g, r, g, g, r, r, r, R, i, H, g],
        [ g, g, r, R, r, r, r, r, b, I, g, g],
        [G, g, r, r, r, r, r, r, b, B, g, g],
        [ G, g, r, r, r, r, r, b, B, r, g, g],
        [G, G, g, r, r, R, S, b, B, r, r, g],
        [ G, g, r, r, r, G, f, B, r, r, r, g],
        [G, g, R, r, r, s, e, F, r, R, r, r],
        [ g, r, r, r, G, c, E, s, r, r, r, R],
        [g, r, r, r, G, g, c, g, g, r, r, r],
        [ r, r, r, S, g, g, c, g, g, r, r, r],
      ]
    }
  </script>
  <script>
    'use strict';

    function memoize(f) {
      var cache = {};
      return function() {
        var key = JSON.stringify([].slice.call(arguments, 0));
        if (!(key in cache))
          cache[key] = f.apply(this, arguments);

        return cache[key];
      };
    }

    Math.sin = memoize(Math.sin);
    Math.cos = memoize(Math.cos);

    function occluse(reference, target) {
      return false;
      if (!reference) {
        return false;
      }
      var i = target.i,
          j = target.j,
          ri = reference.i,
          rj = reference.j;

      if (!heightMap[rj] || !heightMap[rj][ri]) {
        return false;
      }

/*      if (!(rj % 2)) {
        if (!(j > rj && i === ri))
          return false;
//               j > rj && j % 2 === 0 && i === ri + 1;
      } else {
        return j > rj && i === ri ||
               j > rj && j % 2 === 1 && i === ri - 1;
      }
*/
      var current = heightMap[j][i].map(function (height) {
        var getPoint = pointMaker(i, j, height[0], height[1]);
        return [getPoint(0).y, getPoint(3).y];
      });

      var selected = heightMap[rj][ri].map(function (height) {
        var getPoint = pointMaker(ri, rj, height[0], height[1]);
        return [getPoint(0).y, getPoint(3).y];
      });

      var overlaps = false;
      var l = Math.min(current.length, selected.length);
      for (var i = 0; i < l && !overlaps; i++) {
        var rA = current[i],
            rB = selected[i];
        overlaps = !(rA[1] >= rB[0] || rB[1] >= rA[0]);
      }
      if (!overlaps) {
        return false;
      }

      return true;
    }

    var arc = 2*Math.PI/6;
    function pointMaker(i, j, h0, h1) {
      var x = i ? i * tileInfo.step.x : 0,
          y = j ? j * tileInfo.step.y : 0,
          even = !(j % 2),
          side = tileInfo.side;
      if (!even) {
        x += tileInfo.step.x / 2;
      }
      return memoize(function getPoint(i) {
        switch (i) {
          case 0:
            return { x: x, y: y - h0 };
          case 1:
            return {
              x: side * Math.cos(arc*(3.5)) + x,
              y: side * Math.sin(arc*(3.5)) + y - h0
            };
          case 2:
          case 3:
          case 4:
            return {
              x: side * Math.cos(arc*(i+1.5)) + x,
              y: side * Math.sin(arc*(i+1.5)) + y - h1
            };
          case 5:
            return {
              x: side * Math.cos(arc*(-0.5)) + x,
              y: side * Math.sin(arc*(-0.5)) + y - h0
            };
          case 6:
            return { x: x, y: y - h1 };
        }
      });
    }

    var character = null;
    function makeCharacter() {
      if (!character) {
        return;
      }

      var getPoint = pointMaker(character.i, character.j, 0, 80);
      ctx.save();
      ctx.globalAlpha = 1.0;

      // top face
      ctx.beginPath();
      ctx.moveTo(getPoint(3).x, getPoint(3).y);
      ctx.lineTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.closePath();
      ctx.fillStyle = 'red';
      ctx.fill();

      // rigth face
      ctx.beginPath();
      ctx.moveTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(5).x, getPoint(5).y);
      ctx.lineTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#FF3737';
      ctx.fill();
      ctx.stroke();

      // left face
      ctx.beginPath();
      ctx.moveTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(1).x, getPoint(1).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#AA0000';
      ctx.fill();

      ctx.restore();
    }

    function makeCube(i, j, h0, h1) {
      var getPoint = pointMaker(i, j, h0, h1);
      var refTile = { i: i, j: j };

      ctx.save();
      ctx.globalAlpha = 0.5;//occluse(cursorTile, refTile) ? 0.3 : 1.0;
      ctx.strokeStyle = 'black';

      if (cursorTile && sameTile(cursorTile, refTile)) {
        ctx.strokeStyle = 'green';
      }
      else if (selectedTile && sameTile(selectedTile, refTile)) {
        ctx.strokeStyle = 'red';
      }

      // top face
      ctx.beginPath();
      ctx.moveTo(getPoint(3).x, getPoint(3).y);
      ctx.lineTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.closePath();
      ctx.fillStyle = '#33393A';
      ctx.fill();
      ctx.stroke();

      // rigth face
      ctx.beginPath();
      ctx.moveTo(getPoint(4).x, getPoint(4).y);
      ctx.lineTo(getPoint(5).x, getPoint(5).y);
      ctx.lineTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#485152';
      ctx.fill();
      ctx.stroke();

      // left face
      ctx.beginPath();
      ctx.moveTo(getPoint(0).x, getPoint(0).y);
      ctx.lineTo(getPoint(1).x, getPoint(1).y);
      ctx.lineTo(getPoint(2).x, getPoint(2).y);
      ctx.lineTo(getPoint(6).x, getPoint(6).y);
      ctx.closePath();
      ctx.fillStyle = '#2A2F30';
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    function makeTile(i, j, h0, tileName) {
      var origin = pointMaker(i, j, h0, h0)(0);
      var img = tiles[tileName];
      ctx.drawImage(img, origin.x - (img.naturalWidth / 2),
                         origin.y - img.naturalHeight)
    }

    var showLogicalWorld = false;
    function makeColumn(i, j) {
      var heights = heightMap[j][i];
      for (var h = 0, l = heights.length; h < l; h++) {
        var height = heights[h];
        if (height[2]) {
          makeTile(i, j, height[0], height[2]);
        }

        if (showLogicalWorld){
          makeCube(i, j, height[0], height[1]);
        }
      }
    }
    document.addEventListener('keypress', function (evt) {
      if (evt.charCode === 'l'.charCodeAt(0)) {
        showLogicalWorld = !showLogicalWorld;
        cls();
        render();
      }
    });

    function makeRow(j) {
      for (var i=0; i<heightMap[j].length; i++) {
        makeColumn(i, j);
      }
    }

    function makeGrid() {
      for (var j=0; j<heightMap.length; j++) {
        makeRow(j);
      }
    }

    var currentPanel, currentOffset;

    function cls() {
      ctx.clearRect(-1000, -1000, 3000, 3000);
    }

    var movingCamera = false, origin, canvas, ctx, tileInfo = {};
    function setup(width) {
      var side = Math.floor((width/2)/Math.cos(Math.PI/6));
      tileInfo.side = side;
      tileInfo.step = {
        x: width,
        y: side / 2
      };
      canvas = document.getElementById('background');
      ctx = canvas.getContext('2d');

      // Camera
      canvas.addEventListener('mousedown', function(evt) {
        evt.preventDefault();

        movingCamera = true;
        canvas.style.cursor = 'move';
        origin = getCanvasPoint(evt);
      });
      canvas.addEventListener('mouseup', function(evt) {
        canvas.style.cursor = '';
        movingCamera = false;
      });
      canvas.addEventListener('mousemove', function(evt) {
        if (movingCamera) {
          var current = getCanvasPoint(evt);
          var displacement = {
            x: current.x - origin.x,
            y: current.y - origin.y
          }
          cameraOffset = {
            x: cameraOffset.x + displacement.x,
            y: cameraOffset.y + displacement.y,
          };
          
        }
        cls();
        render();
      });
    }

    function getOrigin(gridPoint) {
      var even = !(gridPoint.j % 2);
      return {
        x: (gridPoint.i + 0.5) * tileInfo.step.x,
        y: (gridPoint.j + (even ? 1 : 0)) * tileInfo.step.y
      };
    }

    function mod(v) {
      return Math.sqrt(v.x*v.x + v.y*v.y);
    }

    var ANGLE_30 = Math.PI/6;
    var ANGLE_150 = 5*ANGLE_30; 
    function getFixing(pos, o, gridPoint) {
      var even = !(gridPoint.j % 2);
      var v = {
        x: pos.x - o.x,
        y: pos.y - o.y
      };
      var angle = Math.acos(v.x/mod(v));
      var fixing = { i: 0, j: 0 };
      if (even) {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 2;
        } else if (angle < ANGLE_150) {
          fixing.j = 1;
        } else {
          fixing.j = 2;
        }
      } else {
        if (0 <= angle && angle < ANGLE_30) {
          fixing.i = 1; fixing.j = 1;
        } else if (angle < ANGLE_150) {
          fixing.j = 2;
        } else {
          fixing.j = 1;
        }
      }
      return fixing;
    }

    function getCanvasPoint(evt) {
      var rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left - cameraOffset.x,
        y: evt.clientY - rect.top - cameraOffset.y
      };
    }

    function getTile(evt) {
      var c = getCanvasPoint(evt);
      var gridPoint = {
        i: Math.floor(c.x/tileInfo.step.x),
        j: Math.floor(c.y/tileInfo.step.y)
      }
      var o = getOrigin(gridPoint);
      var fixing = getFixing(c, o, gridPoint);
      return {
        i: gridPoint.i + fixing.i,
        j: gridPoint.j + fixing.j
      }
    }

    var currentTool = { id: '', data: {} };
    function getEnabledTool() {
      var tools = document.getElementsByName('tool');
      for (var i = 0, l = tools.length; i < l; i++) {
        var option = tools[i];
        if (option.checked) {
          if (option.value !== currentTool.id) {
            currentTool.id = option.value;
            currentTool.data = {};
          }
          return currentTool;
        }
      }
    }

    function sameTile(t1, t2) {
      return t1 === t2 || (t1.i === t2.i && t1.j === t2.j);
    }

    var cursorTile = null;
    var selectedTile = null;

    var heightMap = level.world;

    function ortoGrid(width, height) {
      return;
      ctx.save();
      ctx.strokeStyle = 'green';
      for (var x=0; x<width+1; x++) {
        ctx.beginPath();
        ctx.moveTo(x*tileInfo.step.x, -1000);
        ctx.lineTo(x*tileInfo.step.x, +1000);
        ctx.stroke();
      }

      for (var y=0; y<height*2; y++) {
        ctx.beginPath();
        ctx.moveTo(-1000, y*tileInfo.side/2);
        ctx.lineTo(+1000, y*tileInfo.side/2);
        ctx.stroke();
      }
      ctx.restore();
    }
  </script>
</head>
<body>
  <canvas id="background" width="1000" height="650"></canvas>
  <p id="palette">
  </p>
  <script>
    var tiles, cameraOffset, render;
    setTimeout(function () {
      'use strict';

      tiles = {};
      tiles = {

      };
      function addTile() {
        for (var i=0; i<arguments.length; i++) {
          var name = arguments[i];
          if (name in tiles) {
            return;
          }

          var img = document.createElement('IMG');
          img.src = 'img/' + name + '.png';
          img.id = 'tile-' + name;
          document.getElementById('palette').appendChild(img);
          tiles[name] = img;
        }
      }
      addTile(
        'big-grass',
        'small-grass',
        'big-stone',
        'small-stone',
        'river-surface',
        'river-ripple',
        'bridge-left',
        'bridge-right',
        'gate-left',
        'gate-right',
        'gate-top',
        'bridge-support-big-left',
        'bridge-support-big-right',
        'bridge-support-small-left',
        'bridge-support-small-right',
        'bridge2-support-big-left',
        'bridge2-support-big-right',
        'bridge2-support-small-left',
        'bridge2-support-small-right'
      );

      cameraOffset = { x: 0, y: 0};
      setup(70);
  //    setupGrid(15, 15);
      render = function () {
        ctx.setTransform(1, 0, 0, 1, cameraOffset.x, cameraOffset.y);
        makeGrid();
  //      showCenter();
        ortoGrid(10, 10);
      };
      render();
    }, 1000);
  </script>
</body>
</html>

